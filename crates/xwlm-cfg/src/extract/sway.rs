use std::collections::HashSet;
use std::path::{Path, PathBuf};

use super::{ExtractionPlan, resolve_path};

pub fn extract(
    config_path: &Path,
    output_filename: &str,
) -> Result<ExtractionPlan, String> {
    let config_path = config_path
        .canonicalize()
        .map_err(|e| format!("Cannot resolve config path: {e}"))?;

    let output_path = config_path
        .parent()
        .ok_or("Cannot determine config directory")?
        .join(output_filename);

    let mut extracted = Vec::new();
    let mut modified_files = Vec::new();
    let mut visited = HashSet::new();
    let mut source_exists = false;

    visited.insert(config_path.clone());

    parse_file(
        &config_path,
        &output_path,
        &mut extracted,
        &mut modified_files,
        &mut visited,
        &mut source_exists,
    )?;

    let output_content = if extracted.is_empty() {
        String::new()
    } else {
        let mut content =
            String::from("# Generated by xwlm. Do not edit manually.\n\n");
        for line in &extracted {
            content.push_str(line);
            content.push('\n');
        }
        content
    };

    let source_line = if !source_exists && !extracted.is_empty() {
        Some(format!("include {}", output_filename))
    } else {
        None
    };

    Ok(ExtractionPlan {
        output_content,
        modified_files,
        source_line,
        main_config: config_path,
        source_exists,
    })
}

fn parse_file(
    path: &Path,
    output_path: &Path,
    extracted: &mut Vec<String>,
    modified_files: &mut Vec<(PathBuf, String)>,
    visited: &mut HashSet<PathBuf>,
    source_exists: &mut bool,
) -> Result<(), String> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {e}", path.display()))?;

    let lines: Vec<&str> = content.lines().collect();
    let mut kept_lines = Vec::new();
    let mut file_modified = false;
    let Some(base_dir) = path.parent() else {
        return Err(format!(
            "can't find the parent directory {}",
            path.display()
        ));
    };
    let mut i = 0;

    while i < lines.len() {
        let trimmed = lines[i].trim();

        if trimmed.is_empty() || trimmed.starts_with('#') {
            kept_lines.push(lines[i].to_string());
            i += 1;
            continue;
        }

        if is_workspace_line(trimmed) {
            extracted.push(lines[i].to_string());
            file_modified = true;
            i += 1;
            continue;
        }

        if is_output_line(trimmed) {
            if trimmed.contains('{') {
                let mut block = vec![lines[i].to_string()];
                let mut depth = count_char(trimmed, '{') as i32
                    - count_char(trimmed, '}') as i32;
                i += 1;
                while i < lines.len() && depth > 0 {
                    depth += count_char(lines[i], '{') as i32;
                    depth -= count_char(lines[i], '}') as i32;
                    block.push(lines[i].to_string());
                    i += 1;
                }
                extracted.extend(block);
                extracted.push(String::new());
                file_modified = true;
                continue;
            } else {
                extracted.push(lines[i].to_string());
                file_modified = true;
                i += 1;
                continue;
            }
        }

        if let Some(include_path_str) = parse_include_line(trimmed) {
            let resolved = resolve_path(base_dir, &include_path_str);

            if let Ok(canonical) = resolved.canonicalize() {
                if canonical == output_path.canonicalize().unwrap_or_default() {
                    *source_exists = true;
                }

                if !visited.contains(&canonical) {
                    visited.insert(canonical.clone());
                    parse_file(
                        &canonical,
                        output_path,
                        extracted,
                        modified_files,
                        visited,
                        source_exists,
                    )?;
                }
            } else if resolved
                .file_name()
                .and_then(|f| output_path.file_name().map(|o| f == o))
                .unwrap_or(false)
            {
                *source_exists = true;
            }
        }

        kept_lines.push(lines[i].to_string());
        i += 1;
    }

    if file_modified {
        let new_content = kept_lines.join("\n");
        modified_files.push((path.to_path_buf(), new_content));
    }

    Ok(())
}

fn is_output_line(line: &str) -> bool {
    if !line.starts_with("output") {
        return false;
    }
    let rest = line["output".len()..].trim_start();
    if rest.is_empty() {
        return false;
    }

    let (name, after_name) = if let Some(stripped) = rest.strip_prefix('"') {
        if let Some(end) = stripped.find('"') {
            (&stripped[..end], stripped[end + 1..].trim_start())
        } else {
            return false;
        }
    } else {
        match rest.find(char::is_whitespace) {
            Some(end) => (&rest[..end], rest[end..].trim_start()),
            None => return false,
        }
    };

    if name == "*" {
        return false;
    }

    !after_name.is_empty()
}

fn parse_include_line(line: &str) -> Option<String> {
    let rest = line.strip_prefix("include")?;
    let path = rest.trim_start();
    if path.is_empty() {
        return None;
    }
    Some(path.to_string())
}

fn is_workspace_line(line: &str) -> bool {
    if !line.starts_with("workspace") {
        return false;
    }
    let rest = line["workspace".len()..].trim_start();
    rest.split_whitespace()
        .nth(1)
        .is_some_and(|w| w == "output")
}

fn count_char(s: &str, c: char) -> usize {
    s.chars().filter(|&ch| ch == c).count()
}
