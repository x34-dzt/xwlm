use std::collections::HashSet;
use std::path::{Path, PathBuf};

use super::{ExtractionPlan, resolve_path};

pub fn extract(
    config_path: &Path,
    output_filename: &str,
) -> Result<ExtractionPlan, String> {
    let config_path = config_path
        .canonicalize()
        .map_err(|e| format!("Cannot resolve config path: {e}"))?;

    let output_path = config_path
        .parent()
        .ok_or("Cannot determine config directory")?
        .join(output_filename);

    let mut extracted = Vec::new();
    let mut modified_files = Vec::new();
    let mut visited = HashSet::new();
    let mut source_exists = false;

    visited.insert(config_path.clone());

    parse_file(
        &config_path,
        &output_path,
        &mut extracted,
        &mut modified_files,
        &mut visited,
        &mut source_exists,
    )?;

    let output_content = if extracted.is_empty() {
        String::new()
    } else {
        let mut content =
            String::from("# Generated by xwlm. Do not edit manually.\n\n");
        for line in &extracted {
            content.push_str(line);
            content.push('\n');
        }
        content
    };

    let source_line = if !source_exists && !extracted.is_empty() {
        Some(format!("source = {}", output_filename))
    } else {
        None
    };

    Ok(ExtractionPlan {
        output_content,
        modified_files,
        source_line,
        main_config: config_path,
        source_exists,
    })
}

fn parse_file(
    path: &Path,
    output_path: &Path,
    extracted: &mut Vec<String>,
    modified_files: &mut Vec<(PathBuf, String)>,
    visited: &mut HashSet<PathBuf>,
    source_exists: &mut bool,
) -> Result<(), String> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {e}", path.display()))?;

    let mut kept_lines = Vec::new();
    let mut file_modified = false;
    let Some(base_dir) = path.parent() else {
        return Err(format!(
            "can't find the parent directory {}",
            path.display()
        ));
    };

    for line in content.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() || trimmed.starts_with('#') {
            kept_lines.push(line.to_string());
            continue;
        }

        if is_monitor_line(trimmed) || is_workspace_line(trimmed) {
            extracted.push(trimmed.to_string());
            file_modified = true;
            continue;
        }

        if let Some(source_path_str) = parse_source_line(trimmed) {
            let resolved = resolve_path(base_dir, &source_path_str);

            if let Ok(canonical) = resolved.canonicalize() {
                if canonical == output_path.canonicalize().unwrap_or_default() {
                    *source_exists = true;
                }

                if !visited.contains(&canonical) {
                    visited.insert(canonical.clone());
                    parse_file(
                        &canonical,
                        output_path,
                        extracted,
                        modified_files,
                        visited,
                        source_exists,
                    )?;
                }
            } else if resolved
                .file_name()
                .and_then(|f| output_path.file_name().map(|o| f == o))
                .unwrap_or(false)
            {
                *source_exists = true;
            }
        }

        kept_lines.push(line.to_string());
    }

    if file_modified {
        let new_content = kept_lines.join("\n");
        modified_files.push((path.to_path_buf(), new_content));
    }

    Ok(())
}

fn is_monitor_line(line: &str) -> bool {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("monitor") {
        return false;
    }
    let rest = line["monitor".len()..].trim_start();
    rest.starts_with('=')
}

fn is_workspace_line(line: &str) -> bool {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("workspace") {
        return false;
    }
    let rest = line["workspace".len()..].trim_start();
    rest.starts_with('=')
}

fn parse_source_line(line: &str) -> Option<String> {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("source") {
        return None;
    }
    let rest = line["source".len()..].trim_start();
    if !rest.starts_with('=') {
        return None;
    }
    let path = rest[1..].trim();
    if path.is_empty() {
        return None;
    }
    Some(path.to_string())
}
